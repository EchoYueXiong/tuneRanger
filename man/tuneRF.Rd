% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tuneRF.R
\name{tuneRF}
\alias{tuneRF}
\title{tuneRF}
\usage{
tuneRF(task, measure = NULL, iters = 100, num.threads = 1,
  num.trees = 1000, replace = TRUE, save.file.path = "./optpath.RData")
}
\arguments{
\item{task}{The mlr task created by \code{\link[mlr]{makeClassifTask}} or \code{\link[mlr]{makeRegrTask}}.}

\item{measure}{Performance measure to evaluate. Default is auc for classification and mse for regression. Other possible performance measures can be looked up here: https://mlr-org.github.io/mlr-tutorial/release/html/performance/index.html}

\item{iters}{Number of iterations.}

\item{num.threads}{Number of threads. Default is 1.}

\item{num.trees}{Number of trees.}

\item{replace}{Sample with replacement.}

\item{save.file.path}{File to which interim results are saved. Default is optpath.RData in the current working 
directory. If one iteration fails the algorithm can be started again with \code{\link{restartTuneRF}}.}
}
\value{
list with recommended parameters, a trained model with these paramaters and a data.frame with all evaluated hyperparameters and performance and time results for each run
}
\description{
Automatic tuning of random forests with one line of code.
}
\details{
Model based optimization is used as tuning strategy and the three parameters min.node.size, sample.fraction and mtry are tuned at once. Out-of-bag predictions are used for evaluation, which makes it much faster than other packages and tuning strategies that use for example 5-fold cross-validation. Classification as well as regression is supported. 
The measure that should be optimized can be chosen from the list of measures in mlr: http://mlr-org.github.io/mlr-tutorial/devel/html/measures/index.html
}
\examples{
library(tuneRF)
library(mlr)
# iris is a bit nonsense here
# A mlr task has to be created in order to use the package

# the already existing iris task is used here
unlink("./optpath.RData")
estimateTuneRFTime(iris.task)

res = tuneRF(iris.task, measure = list(multiclass.brier), num.trees = 1000, 
  num.threads = 8, iters = 100)
  
# Best 5 \% of the results
res[res$multiclass.brier < quantile(res$multiclass.brier, 0.05),]
}
